/**
 * Hook for filtering vulnerabilities and managing filter state
 * Combines filter state management with filtering logic
 */

import { useState, useMemo, useCallback, useEffect } from 'react';
import { useVulnerabilityData } from './useVulnerabilityData';
import { filterVulnerabilities } from '../utils/dataTransform';
import { FlattenedVulnerability } from '../types/vulnerability';

export interface FilterState {
  severity?: string[];
  kaiStatus?: string[];
  excludeKaiStatus?: string[];
  packageName?: string;
  searchQuery?: string;
}

export interface FilterStats {
  total: number;
  filtered: number;
  excluded: number;
}

export interface UseVulnerabilityFiltersResult {
  filteredData: FlattenedVulnerability[];
  allData: FlattenedVulnerability[];
  filters: FilterState;
  setFilters: (filters: FilterState) => void;
  updateFilter: <K extends keyof FilterState>(
    key: K,
    value: FilterState[K]
  ) => void;
  clearFilters: () => void;
  applyAnalysis: () => void;
  applyAIAnalysis: () => void;
  filterStats: FilterStats;
  isLoading: boolean;
  selectedCveIds: string[];
  selectedVulnerabilities: FlattenedVulnerability[];
  toggleSelection: (cveId: string) => void;
  selectAll: (vulnerabilities: FlattenedVulnerability[]) => void;
  clearSelection: () => void;
  isSelected: (cveId: string) => boolean;
  removeSelection: (cveId: string) => void;
  maxSelection: number;
}

const MAX_SELECTION_COUNT = 4;
const SELECTION_STORAGE_KEY = 'kai-cyber:selected-cves';

/**
 * Combined hook for filtering vulnerabilities and managing filter state
 * Handles Analysis and AI Analysis button logic
 */
export function useVulnerabilityFilters(): UseVulnerabilityFiltersResult {
  const { vulnerabilities: allData, isLoading } = useVulnerabilityData();
  const [filters, setFilters] = useState<FilterState>({});
  const [selectedCveIds, setSelectedCveIds] = useState<string[]>([]);

  // Hydrate selection from local storage
  useEffect(() => {
    if (typeof window === 'undefined') return;
    const stored = window.localStorage.getItem(SELECTION_STORAGE_KEY);
    if (stored) {
      try {
        const parsed = JSON.parse(stored) as string[];
        if (Array.isArray(parsed)) {
          setSelectedCveIds(parsed.slice(0, MAX_SELECTION_COUNT));
        }
      } catch {
        // ignore corrupted storage
      }
    }
  }, []);

  // Memoize filtered data for performance
  const filteredData = useMemo(() => {
    if (!allData || allData.length === 0) {
      return [];
    }
    return filterVulnerabilities(allData, filters);
  }, [allData, filters]);

  // Update a specific filter
  const updateFilter = useCallback(
    <K extends keyof FilterState>(key: K, value: FilterState[K]) => {
      setFilters((prev) => ({
        ...prev,
        [key]: value,
      }));
    },
    []
  );

  // Clear all filters
  const clearFilters = useCallback(() => {
    setFilters({});
  }, []);

  // Selection helpers
  const toggleSelection = useCallback((cveId: string) => {
    setSelectedCveIds((prev) => {
      if (prev.includes(cveId)) {
        return prev.filter((id) => id !== cveId);
      }

      if (prev.length >= MAX_SELECTION_COUNT) {
        return prev;
      }

      return [...prev, cveId];
    });
  }, []);

  const selectAll = useCallback((vulnerabilities: FlattenedVulnerability[]) => {
    setSelectedCveIds(
      vulnerabilities
        .slice(0, MAX_SELECTION_COUNT)
        .map((v) => v.cve)
    );
  }, []);

  const clearSelection = useCallback(() => {
    setSelectedCveIds([]);
  }, []);

  const isSelected = useCallback(
    (cveId: string) => selectedCveIds.includes(cveId),
    [selectedCveIds]
  );

  const removeSelection = useCallback((cveId: string) => {
    setSelectedCveIds((prev) => prev.filter((id) => id !== cveId));
  }, []);

  const selectedVulnerabilities = useMemo(() =>
    selectedCveIds
      .map((id) => allData.find((v) => v.cve === id))
      .filter((v): v is FlattenedVulnerability => Boolean(v)),
    [selectedCveIds, allData]
  );

  // Ensure selection does not contain entries missing from current dataset
  useEffect(() => {
    setSelectedCveIds((prev) =>
      prev.filter((id) => allData.some((v) => v.cve === id)).slice(0, MAX_SELECTION_COUNT)
    );
  }, [allData]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    window.localStorage.setItem(SELECTION_STORAGE_KEY, JSON.stringify(selectedCveIds));
  }, [selectedCveIds]);

  // Apply Analysis filter - exclude "invalid - norisk"
  const applyAnalysis = useCallback(() => {
    setFilters((prev) => ({
      ...prev,
      excludeKaiStatus: ['invalid - norisk'],
    }));
  }, []);

  // Apply AI Analysis filter - exclude "ai-invalid-norisk"
  const applyAIAnalysis = useCallback(() => {
    setFilters((prev) => ({
      ...prev,
      excludeKaiStatus: ['ai-invalid-norisk'],
    }));
  }, []);

  // Calculate filter statistics
  const filterStats = useMemo((): FilterStats => {
    const total = allData.length;
    const filtered = filteredData.length;
    const excluded = total - filtered;
    return {
      total,
      filtered,
      excluded,
    };
  }, [allData.length, filteredData.length]);

  return {
    selectedVulnerabilities,
    filteredData,
    allData,
    filters,
    setFilters,
    updateFilter,
    clearFilters,
    applyAnalysis,
    applyAIAnalysis,
    filterStats,
    isLoading,
    selectedCveIds,
    toggleSelection,
    selectAll,
    clearSelection,
    isSelected,
    maxSelection: MAX_SELECTION_COUNT,
    removeSelection,
  };
}

